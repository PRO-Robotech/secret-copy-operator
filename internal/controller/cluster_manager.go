/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"crypto/sha256"
	"fmt"
	"sync"
	"time"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/tools/clientcmd"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// ClusterManager manages connections to remote clusters with caching
type ClusterManager struct {
	mu                      sync.RWMutex
	clients                 map[string]*cachedClient
	ttl                     time.Duration
	scheme                  *runtime.Scheme
	maxConcurrentReconciles int
}

type cachedClient struct {
	client         client.Client
	kubeconfigHash string
	createdAt      time.Time
}

// NewClusterManager creates a new ClusterManager
func NewClusterManager(ttl time.Duration, scheme *runtime.Scheme, maxConcurrentReconciles int) *ClusterManager {
	cm := &ClusterManager{
		clients:                 make(map[string]*cachedClient),
		ttl:                     ttl,
		scheme:                  scheme,
		maxConcurrentReconciles: maxConcurrentReconciles,
	}
	go cm.cleanupLoop()
	return cm
}

// GetClient returns a cached client or creates a new one
func (cm *ClusterManager) GetClient(kubeconfigSecret *corev1.Secret) (client.Client, error) {
	// Get kubeconfig from secret
	kubeconfigData := cm.getKubeconfigFromSecret(kubeconfigSecret)
	if kubeconfigData == nil {
		return nil, fmt.Errorf("kubeconfig not found in secret %s/%s", kubeconfigSecret.Namespace, kubeconfigSecret.Name)
	}

	cacheKey := kubeconfigSecret.Namespace + "/" + kubeconfigSecret.Name
	configHash := cm.hashKubeconfig(kubeconfigData)

	// Check cache with read lock
	cm.mu.RLock()
	if cached, ok := cm.clients[cacheKey]; ok {
		// Check TTL and that kubeconfig hasn't changed
		if time.Since(cached.createdAt) < cm.ttl && cached.kubeconfigHash == configHash {
			cm.mu.RUnlock()
			return cached.client, nil
		}
	}
	cm.mu.RUnlock()
	cm.mu.Lock()
	defer cm.mu.Unlock()

	if cached, ok := cm.clients[cacheKey]; ok {
		if time.Since(cached.createdAt) < cm.ttl && cached.kubeconfigHash == configHash {
			return cached.client, nil
		}
	}

	// Create REST config from kubeconfig
	restConfig, err := clientcmd.RESTConfigFromKubeConfig(kubeconfigData)
	if err != nil {
		return nil, fmt.Errorf("failed to parse kubeconfig: %w", err)
	}

	// Configure timeouts and rate limits based on concurrency
	// Each reconcile does ~4 API calls, multiply by 5 for headroom
	restConfig.Timeout = 30 * time.Second
	restConfig.QPS = float32(cm.maxConcurrentReconciles * 5)
	restConfig.Burst = cm.maxConcurrentReconciles * 10

	// Create client
	cl, err := client.New(restConfig, client.Options{
		Scheme: cm.scheme,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create client: %w", err)
	}

	// Cache the client
	cm.clients[cacheKey] = &cachedClient{
		client:         cl,
		kubeconfigHash: configHash,
		createdAt:      time.Now(),
	}

	return cl, nil
}

// getKubeconfigFromSecret extracts kubeconfig from secret
// Kubeconfig is always stored under "value" key (generated by certs operator)
func (cm *ClusterManager) getKubeconfigFromSecret(secret *corev1.Secret) []byte {
	return secret.Data["value"]
}

// hashKubeconfig returns hash of kubeconfig for change detection
func (cm *ClusterManager) hashKubeconfig(data []byte) string {
	h := sha256.Sum256(data)
	return fmt.Sprintf("%x", h[:8])
}

// cleanupLoop removes expired clients
func (cm *ClusterManager) cleanupLoop() {
	ticker := time.NewTicker(1 * time.Minute)
	defer ticker.Stop()

	for range ticker.C {
		cm.mu.Lock()
		now := time.Now()
		for key, cached := range cm.clients {
			if now.Sub(cached.createdAt) > cm.ttl {
				delete(cm.clients, key)
			}
		}
		cm.mu.Unlock()
	}
}
